<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flappy Bird Êú¨Âú∞Â∞èÊ∏∏Êàè</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "PingFang SC", "Microsoft YaHei", system-ui, -apple-system, sans-serif;
      }

      body {
        margin: 0;
        display: grid;
        place-items: center;
        min-height: 100vh;
        background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
        color: #f8fafc;
      }

      .container {
        text-align: center;
        padding: 24px;
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        box-shadow: 0 24px 40px rgba(15, 23, 42, 0.4);
        position: relative;
      }

      canvas {
        background: linear-gradient(180deg, #38bdf8 0%, #0ea5e9 45%, #0f172a 100%);
        border-radius: 16px;
        display: block;
      }

      .hud {
        display: flex;
        justify-content: space-between;
        margin-top: 12px;
        font-size: 14px;
        color: #e2e8f0;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-top: 12px;
      }

      .help {
        margin-top: 12px;
        font-size: 13px;
        color: #94a3b8;
      }

      button {
        padding: 8px 16px;
        border-radius: 999px;
        border: none;
        background: #38bdf8;
        color: #0f172a;
        cursor: pointer;
        font-weight: 600;
      }

      button:hover {
        background: #7dd3fc;
      }

      .bonus-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 32px;
        font-weight: bold;
        color: #fbbf24;
        text-shadow: 0 0 10px rgba(251, 191, 36, 0.8), 0 0 20px rgba(251, 191, 36, 0.5);
        pointer-events: none;
        opacity: 0;
      }

      .bonus-indicator.show {
        animation: bonusPulse 0.8s ease-out;
      }

      @keyframes bonusPulse {
        0% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(0.5);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.2);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(1);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="game" width="420" height="520"></canvas>
      <div class="hud">
        <span id="score">ÂæóÂàÜÔºö0</span>
        <span id="best">ÊúÄ‰Ω≥Ôºö0</span>
        <span id="lives">ÁîüÂëΩÔºö1</span>
      </div>
      <div class="controls">
        <button id="restart">ÈáçÊñ∞ÂºÄÂßã</button>
        <button id="toggle-mode">ÂàáÊç¢Âà∞Âõ∞ÈöæÊ®°Âºè</button>
      </div>
      <div class="help">
        ÊåâÁ©∫Ê†º / ÁÇπÂáªÂ±èÂπïËÆ©Â∞èÈ∏üÈ£ûËµ∑Êù•„ÄÇ<br>
        <span style="font-size: 11px; color: #64748b;">
          ÊèêÁ§∫ÔºöÂõ∞ÈöæÊ®°Âºè10ÂàÜÂêéÂá∫Áé∞ÂèåÈó¥ÈöôÁÆ°ÈÅì | URLÂèÇÊï∞ ?doublegap=1 ÂèØÂº∫Âà∂ÂºÄÂêØ
        </span>
      </div>
      <div id="bonus-indicator" class="bonus-indicator"></div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const bestEl = document.getElementById("best");
      const livesEl = document.getElementById("lives");
      const restartBtn = document.getElementById("restart");
      const toggleModeBtn = document.getElementById("toggle-mode");
      const bonusIndicator = document.getElementById("bonus-indicator");
      const demoDoubleGap = new URLSearchParams(window.location.search).get("doublegap") === "1";

      const bestKey = (mode) => `flappy-best-${mode}`;

      const game = {
        state: "ready",
        score: 0,
        best: 0,
        lives: 1,
        invincibleUntil: 0,
        gravity: 0.42,
        flapStrength: -7.5,
        speed: 2.4,
        gap: 140,
        pipeWidth: 64,
        pipeSpacing: 190,
        minSpacing: 150,
        mode: "normal",
        movingChance: 0,
        moveAmplitude: 0,
        moveSpeed: 0,
        moveAmplitudeX: 0,
        moveSpeedX: 0,
        bird: {
          x: 120,
          y: 260,
          radius: 16,
          velocity: 0,
          tilt: 0,
        },
        pipes: [],
        hearts: [],
        frame: 0,
        lastLifeScore: 0,
        cheatEnabled: false,
        cheatInput: "",
        cheatTimeout: null,
        inBonusStage: false,
        bonusStageProgress: 0,
        nextBonusCheck: 60,
      };

      const applyMode = (mode) => {
        game.mode = mode;
        if (mode === "hard") {
          game.speed = 2.8;
          game.gap = 125;
          game.pipeSpacing = 200;
          game.minSpacing = 160;
          game.movingChance = 0.45;
          game.moveAmplitude = 42;
          game.moveSpeed = 0.025;
          game.moveAmplitudeX = 18;
          game.moveSpeedX = 0.03;
          toggleModeBtn.textContent = "ÂàáÊç¢Âà∞ÊôÆÈÄöÊ®°Âºè";
        } else {
          game.speed = 2.4;
          game.gap = 140;
          game.pipeSpacing = 220;
          game.minSpacing = 170;
          game.movingChance = 0;
          game.moveAmplitude = 0;
          game.moveSpeed = 0;
          game.moveAmplitudeX = 0;
          game.moveSpeedX = 0;
          toggleModeBtn.textContent = "ÂàáÊç¢Âà∞Âõ∞ÈöæÊ®°Âºè";
        }
        game.best = Number(localStorage.getItem(bestKey(mode))) || 0;
        updateHud();
      };

      const getDifficultyConfig = () => {
        const tier = game.mode === "hard" ? Math.floor(game.score / 20) : 0;
        const tierBoost = Math.min(tier, 5);
        const speed = game.speed * (1 + tierBoost * 0.08);
        const pipeSpacing = Math.max(150, game.pipeSpacing - tierBoost * 6);
        const minSpacing = Math.max(120, game.minSpacing - tierBoost * 3);
        const moveSpeed = game.moveSpeed * (1 + tierBoost * 0.12);
        const moveSpeedX = game.moveSpeedX * (1 + tierBoost * 0.12);

        return {
          speed,
          pipeSpacing,
          minSpacing,
          moveSpeed,
          moveSpeedX,
          tier,
        };
      };

      const resetGame = () => {
        game.state = "ready";
        game.score = 0;
        game.lives = 1;
        game.invincibleUntil = 0;
        game.bird.y = 260;
        game.bird.velocity = 0;
        game.bird.tilt = 0;
        game.pipes = [];
        game.hearts = [];
        game.frame = 0;
        game.lastLifeScore = 0;
        game.inBonusStage = false;
        game.bonusStageProgress = 0;
        game.nextBonusCheck = 60;
        updateHud();
      };

      const startGame = () => {
        if (game.state !== "ready") return;
        game.state = "running";
        spawnPipe();
      };

      const updateHud = () => {
        scoreEl.textContent = `ÂæóÂàÜÔºö${game.score}`;
        bestEl.textContent = `ÊúÄ‰Ω≥Ôºö${game.best}`;
        livesEl.textContent = `ÁîüÂëΩÔºö${game.lives}`;
      };

      const showBonusIndicator = (text) => {
        bonusIndicator.textContent = text;
        bonusIndicator.classList.remove("show");
        void bonusIndicator.offsetWidth;
        bonusIndicator.classList.add("show");
      };

      const createDoubleGaps = (minTop, maxTop) => {
        const gapHeight = game.gap;
        const minSegment = 40;

        const totalAvailableSpace = maxTop - minTop;
        const requiredSpace = gapHeight * 2 + minSegment;

        if (totalAvailableSpace < requiredSpace) {
          return [
            {
              top: minTop + Math.random() * (maxTop - minTop),
              height: gapHeight,
            },
          ];
        }

        const layoutMode = Math.floor(Math.random() * 3);

        let firstGapTop;
        let secondGapTop;

        if (layoutMode === 0) {
          const flexSpace = totalAvailableSpace - gapHeight * 2;

          const topRatio = 0.2 + Math.random() * 0.2;
          const topPipe = flexSpace * topRatio;

          const midRatio = 0.3 + Math.random() * 0.3;
          const midPipe = Math.max(minSegment, flexSpace * midRatio);

          firstGapTop = minTop + topPipe;
          secondGapTop = firstGapTop + gapHeight + midPipe;
        } else if (layoutMode === 1) {
          const flexSpace = totalAvailableSpace - gapHeight * 2;

          const topRatio = 0.1 + Math.random() * 0.15;
          const topPipe = flexSpace * topRatio;

          const midRatio = 0.15 + Math.random() * 0.25;
          const midPipe = Math.max(minSegment, flexSpace * midRatio);

          firstGapTop = minTop + topPipe;
          secondGapTop = firstGapTop + gapHeight + midPipe;
        } else {
          const flexSpace = totalAvailableSpace - gapHeight * 2;

          const topRatio = 0.3 + Math.random() * 0.3;
          const topPipe = flexSpace * topRatio;

          const midRatio = 0.2 + Math.random() * 0.2;
          const midPipe = Math.max(minSegment, flexSpace * midRatio);

          firstGapTop = minTop + topPipe;
          secondGapTop = firstGapTop + gapHeight + midPipe;
        }

        return [
          {
            top: firstGapTop,
            height: gapHeight,
          },
          {
            top: secondGapTop,
            height: gapHeight,
          },
        ];
      };

      const createTunnelGaps = (minTop, maxTop) => {
        const gapHeight = game.gap;
        const numTunnels = 1 + Math.floor(Math.random() * 2);
        const gaps = [];

        const availableHeight = maxTop - minTop;
        const tunnelSpacing = 60;

        if (numTunnels === 1) {
          const centerBias = 0.3;
          const center = (minTop + maxTop) / 2;
          const range = (maxTop - minTop - gapHeight) * (1 - centerBias);
          const offset = (Math.random() - 0.5) * range;
          gaps.push({
            top: center - gapHeight / 2 + offset,
            height: gapHeight,
          });
        } else {
          const totalRequired = gapHeight * 2 + tunnelSpacing;
          if (availableHeight >= totalRequired) {
            const spacing = (availableHeight - gapHeight * 2) / 3;
            gaps.push({
              top: minTop + spacing,
              height: gapHeight,
            });
            gaps.push({
              top: minTop + spacing * 2 + gapHeight,
              height: gapHeight,
            });
          } else {
            gaps.push({
              top: minTop + (maxTop - minTop - gapHeight) / 2,
              height: gapHeight,
            });
          }
        }

        return gaps;
      };

      const spawnBonusStagePipes = () => {
        const minTop = 30;
        const maxTop = canvas.height - game.gap - 60;
        const numPipes = 5;
        const pipeSpacing = 10;

        const tunnelGaps = createTunnelGaps(minTop, maxTop);

        for (let i = 0; i < numPipes; i++) {
          const baseX = canvas.width + 40 + i * (game.pipeWidth + pipeSpacing);

          game.pipes.push({
            baseX,
            x: baseX,
            baseTop: tunnelGaps[0].top,
            top: tunnelGaps[0].top,
            gaps: JSON.parse(JSON.stringify(tunnelGaps)),
            spacing: pipeSpacing,
            movingY: false,
            movingX: false,
            phaseY: 0,
            phaseX: 0,
            tierIndex: 0,
            passed: false,
            initialGaps: JSON.parse(JSON.stringify(tunnelGaps)),
            isBonusPipe: true,
          });
        }

        game.inBonusStage = true;
        game.bonusStageProgress = 0;
        showBonusIndicator("üéÅ Â•ñÂä±ÈößÈÅìÔºÅ");
      };

      const spawnPipe = () => {
        if (!game.inBonusStage && game.score >= game.nextBonusCheck && game.score >= 40) {
          if (Math.random() < 0.2) {
            spawnBonusStagePipes();
            game.nextBonusCheck = Math.ceil((game.score + 1) / 20) * 20 + 20;
            return;
          }
          game.nextBonusCheck = Math.ceil((game.score + 1) / 20) * 20 + 20;
        }

        if (game.inBonusStage) {
          return;
        }

        const difficulty = getDifficultyConfig();
        const tierIndex = difficulty.tier;

        const minTop = 30;
        const maxTop = canvas.height - game.gap - 60;

        let baseTop = minTop + Math.random() * (maxTop - minTop);
        const spacingVariance = game.mode === "hard" ? Math.random() * 30 - 20 : 0;
        const spacing = Math.max(difficulty.minSpacing, difficulty.pipeSpacing + spacingVariance);
        const movingY = Math.random() < game.movingChance;
        const movingX = Math.random() < game.movingChance;
        const baseX = canvas.width + 40;

        let doubleGapChance = 0;
        if (demoDoubleGap) {
          doubleGapChance = 1;
        } else if (game.mode === "hard") {
          if (game.score >= 30) {
            doubleGapChance = 0.5;
          } else if (game.score >= 10) {
            doubleGapChance = 0.3;
          }
        } else if (game.score >= 20) {
          doubleGapChance = 0.2;
        }

        const useDoubleGap = Math.random() < doubleGapChance;

        const gaps = useDoubleGap
          ? createDoubleGaps(minTop, maxTop)
          : [
              {
                top: baseTop,
                height: game.gap,
              },
            ];
        if (useDoubleGap) {
          baseTop = gaps[0].top;
        }

        const heartChance = 0.12;
        const shouldSpawnHeart = Math.random() < heartChance;
        const heartGap = gaps[Math.floor(Math.random() * gaps.length)];
        if (shouldSpawnHeart && heartGap) {
          game.hearts.push({
            x: baseX + game.pipeWidth / 2,
            y: heartGap.top + heartGap.height / 2,
            radius: 10,
          });
        }

        game.pipes.push({
          baseX,
          x: baseX,
          baseTop,
          top: baseTop,
          gaps,
          spacing,
          movingY,
          movingX,
          phaseY: Math.random() * Math.PI * 2,
          phaseX: Math.random() * Math.PI * 2,
          tierIndex,
          passed: false,
          initialGaps: JSON.parse(JSON.stringify(gaps)),
          isBonusPipe: false,
        });
      };

      const flap = () => {
        if (game.state === "over") {
          resetGame();
          return;
        }
        startGame();
        game.bird.velocity = game.flapStrength;
      };

      const checkCollision = (pipe) => {
        const bird = game.bird;
        const withinX = bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + game.pipeWidth;
        if (!withinX) return false;
        const gaps = pipe.gaps || [
          {
            top: pipe.top,
            height: game.gap,
          },
        ];
        const withinGap = gaps.some((gap) => {
          const gapTop = gap.top;
          const gapBottom = gap.top + gap.height;
          return bird.y - bird.radius >= gapTop && bird.y + bird.radius <= gapBottom;
        });
        return !withinGap;
      };

      const handleHit = (now) => {
        if (game.lives > 1) {
          game.lives -= 1;
          game.invincibleUntil = now + 1200;
          game.bird.velocity = game.flapStrength;
          game.bird.y = Math.min(Math.max(game.bird.y, 80), canvas.height - 120);
          updateHud();
        } else {
          game.state = "over";
        }
      };

      const updateGapsPosition = (pipe, delta) => {
        const actualMinTop = 30;
        const actualMaxTop = canvas.height - game.gap - 60;

        const newGaps = pipe.gaps.map((gap, index) => {
          const proposedTop = gap.top + delta;

          let gapMinTop = actualMinTop;
          let gapMaxTop = actualMaxTop - gap.height;

          if (pipe.gaps.length > 1) {
            const minSegment = 40;

            if (index === 0) {
              const secondGap = pipe.gaps[1];
              gapMaxTop = Math.min(gapMaxTop, actualMaxTop - gap.height - minSegment - secondGap.height);
            } else if (index === 1) {
              const firstGap = pipe.gaps[0];
              gapMinTop = Math.max(gapMinTop, firstGap.top + firstGap.height + minSegment);
            }
          }

          const clampedTop = Math.max(gapMinTop, Math.min(gapMaxTop, proposedTop));

          return {
            top: clampedTop,
            height: gap.height,
          };
        });

        if (newGaps.length === 2) {
          const gap1Bottom = newGaps[0].top + newGaps[0].height;
          const gap2Top = newGaps[1].top;
          const minSegment = 40;

          if (gap2Top - gap1Bottom < minSegment) {
            newGaps[1].top = gap1Bottom + minSegment;

            if (newGaps[1].top + newGaps[1].height > actualMaxTop) {
              newGaps[0].top = actualMaxTop - newGaps[1].height - minSegment - newGaps[0].height;
            }
          }
        }

        return newGaps;
      };

      const update = (now) => {
        if (game.state === "running") {
          const difficulty = getDifficultyConfig();
          game.bird.velocity += game.gravity;
          game.bird.y += game.bird.velocity;
          game.bird.tilt = Math.min(game.bird.velocity * 4, 18);

          const lastPipe = game.pipes[game.pipes.length - 1];
          const requiredSpacing = lastPipe ? lastPipe.spacing : difficulty.pipeSpacing;
          if (!lastPipe || canvas.width - lastPipe.baseX >= requiredSpacing) {
            spawnPipe();
          }

          const minTop = 50;
          const maxTop = canvas.height - game.gap - 80;

          game.pipes.forEach((pipe) => {
            pipe.baseX -= difficulty.speed;

            if (pipe.movingY) {
              pipe.phaseY += difficulty.moveSpeed;
              const offset = Math.sin(pipe.phaseY) * game.moveAmplitude;
              const proposedBaseTop = pipe.baseTop + offset;

              if (pipe.gaps.length === 1) {
                const clampedTop = Math.max(minTop, Math.min(maxTop, proposedBaseTop));
                const delta = clampedTop - pipe.top;
                pipe.top = clampedTop;
                pipe.gaps[0].top = clampedTop;
              } else {
                const delta = proposedBaseTop - pipe.top;
                pipe.gaps = updateGapsPosition(pipe, delta);
                pipe.top = pipe.gaps[0].top;
              }
            }

            if (pipe.movingX) {
              pipe.phaseX += difficulty.moveSpeedX;
              const offsetX = Math.sin(pipe.phaseX) * game.moveAmplitudeX;
              pipe.x = pipe.baseX + offsetX;
            } else {
              pipe.x = pipe.baseX;
            }

            if (!pipe.passed && pipe.x + game.pipeWidth < game.bird.x) {
              pipe.passed = true;
              game.score += 1;

              if (game.score > game.best) {
                game.best = game.score;
                localStorage.setItem(bestKey(game.mode), game.best);
              }

              if (pipe.isBonusPipe) {
                game.bonusStageProgress += 1;
                if (game.bonusStageProgress >= 5) {
                  game.inBonusStage = false;
                  showBonusIndicator("‚ú® ÂÆåÊàêÔºÅ");
                }
              }

              updateHud();
            }
          });

          game.pipes = game.pipes.filter((pipe) => pipe.x + game.pipeWidth > -20);
          game.hearts = game.hearts
            .map((heart) => ({
              ...heart,
              x: heart.x - difficulty.speed,
            }))
            .filter((heart) => heart.x + heart.radius > -20);

          game.hearts = game.hearts.filter((heart) => {
            const dx = game.bird.x - heart.x;
            const dy = game.bird.y - heart.y;
            const distance = Math.hypot(dx, dy);
            if (distance < game.bird.radius + heart.radius) {
              game.lives += 1;
              showBonusIndicator("‚ù§Ô∏è +1");
              updateHud();
              return false;
            }
            return true;
          });

          const hitPipe = game.pipes.some((pipe) => checkCollision(pipe));
          const hitGround = game.bird.y + game.bird.radius > canvas.height - 40;
          const hitSky = game.bird.y - game.bird.radius < 0;
          const isInvincible = now < game.invincibleUntil;

          if (!isInvincible && (hitPipe || hitGround || hitSky)) {
            handleHit(now);
          }
        }

        if (game.state === "over") {
          game.bird.velocity += game.gravity * 0.8;
          game.bird.y += game.bird.velocity;
          game.bird.tilt = Math.min(game.bird.velocity * 4, 28);
        }

        game.frame += 1;
      };

      const draw = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawBackdrop();
        drawGround();
        drawPipes();
        drawHearts();
        drawBird();
        drawOverlay();
      };

      const drawBackdrop = () => {
        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
        for (let i = 0; i < 6; i += 1) {
          ctx.beginPath();
          ctx.ellipse(60 + i * 70, 80 + (i % 2) * 20, 32, 16, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      };

      const drawGround = () => {
        ctx.fillStyle = "#1e293b";
        ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
        ctx.fillStyle = "#94a3b8";
        for (let i = 0; i < canvas.width; i += 32) {
          ctx.fillRect(i, canvas.height - 32, 16, 8);
        }
      };

      const pipeColors = [
        { body: "#22c55e", cap: "#15803d" },
        { body: "#fbbf24", cap: "#f59e0b" },
        { body: "#ef4444", cap: "#dc2626" },
        { body: "#a855f7", cap: "#7e22ce" },
      ];

      const drawPipes = () => {
        game.pipes.forEach((pipe) => {
          const isDoubleGap = pipe.gaps && pipe.gaps.length > 1 && !pipe.isBonusPipe;

          let palette;
          if (pipe.isBonusPipe) {
            palette = { body: "#fbbf24", cap: "#f59e0b" };
          } else {
            palette = pipeColors[pipe.tierIndex % pipeColors.length];
          }

          const gaps = pipe.gaps || [
            {
              top: pipe.top,
              height: game.gap,
            },
          ];
          const sortedGaps = [...gaps].sort((a, b) => a.top - b.top);

          let currentY = 0;

          sortedGaps.forEach((gap) => {
            if (gap.top > currentY) {
              ctx.fillStyle = palette.body;
              ctx.fillRect(pipe.x, currentY, game.pipeWidth, gap.top - currentY);
            }

            ctx.fillStyle = palette.cap;
            ctx.fillRect(pipe.x - 4, gap.top - 12, game.pipeWidth + 8, 12);
            ctx.fillRect(pipe.x - 4, gap.top + gap.height, game.pipeWidth + 8, 12);

            currentY = gap.top + gap.height;
          });

          if (currentY < canvas.height - 40) {
            ctx.fillStyle = palette.body;
            ctx.fillRect(pipe.x, currentY, game.pipeWidth, canvas.height - currentY - 40);
          }

          if (pipe.isBonusPipe) {
            const glowAlpha = 0.3 + 0.2 * Math.sin(game.frame / 10);
            ctx.fillStyle = `rgba(251, 191, 36, ${glowAlpha})`;
            ctx.fillRect(pipe.x - 2, 0, game.pipeWidth + 4, canvas.height - 40);
          }

          if (isDoubleGap && sortedGaps.length === 2) {
            ctx.save();
            const gap1Bottom = sortedGaps[0].top + sortedGaps[0].height;
            const gap2Top = sortedGaps[1].top;
            const middleY = (gap1Bottom + gap2Top) / 2;

            ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(pipe.x, middleY);
            ctx.lineTo(pipe.x + game.pipeWidth, middleY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
          }
        });
      };

      const drawHearts = () => {
        game.hearts.forEach((heart) => {
          ctx.save();
          ctx.fillStyle = "#fb7185";
          ctx.beginPath();
          ctx.moveTo(heart.x, heart.y + heart.radius / 2);
          ctx.bezierCurveTo(
            heart.x + heart.radius,
            heart.y - heart.radius / 2,
            heart.x + heart.radius * 1.6,
            heart.y + heart.radius / 2,
            heart.x,
            heart.y + heart.radius * 1.6
          );
          ctx.bezierCurveTo(
            heart.x - heart.radius * 1.6,
            heart.y + heart.radius / 2,
            heart.x - heart.radius,
            heart.y - heart.radius / 2,
            heart.x,
            heart.y + heart.radius / 2
          );
          ctx.fill();
          ctx.restore();
        });
      };

      const drawBird = () => {
        const { x, y, radius } = game.bird;
        const isInvincible = performance.now() < game.invincibleUntil;
        const flicker = isInvincible ? 0.5 + 0.4 * Math.sin(performance.now() / 80) : 1;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((Math.PI / 180) * game.bird.tilt);
        ctx.globalAlpha = flicker;

        ctx.fillStyle = "#fbbf24";
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#0f172a";
        ctx.beginPath();
        ctx.arc(6, -4, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#fb7185";
        ctx.beginPath();
        ctx.moveTo(radius, 0);
        ctx.lineTo(radius + 10, 4);
        ctx.lineTo(radius, 8);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      };

      const drawOverlay = () => {
        if (game.state === "ready") {
          drawCenteredText("Flappy Bird", 42, 220);
          drawCenteredText("ÊåâÁ©∫Ê†ºÂºÄÂßã", 18, 260);
        }
        if (game.state === "over") {
          drawCenteredText("Ê∏∏ÊàèÁªìÊùü", 32, 220);
          drawCenteredText("ÁÇπÂáªÈáçÊñ∞ÂºÄÂßã", 18, 260);
        }

        if (game.inBonusStage) {
          ctx.save();
          ctx.fillStyle = "rgba(251, 191, 36, 0.9)";
          ctx.font = 'bold 20px "PingFang SC", "Microsoft YaHei", sans-serif';
          ctx.textAlign = "center";
          ctx.fillText(`üéÅ Â•ñÂä±ÈößÈÅì ${game.bonusStageProgress}/5`, canvas.width / 2, 30);
          ctx.restore();
        }
      };

      const drawCenteredText = (text, size, y) => {
        ctx.save();
        ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
        ctx.font = `bold ${size}px "PingFang SC", "Microsoft YaHei", sans-serif`;
        ctx.textAlign = "center";
        ctx.fillText(text, canvas.width / 2, y);
        ctx.restore();
      };

      const loop = (now) => {
        update(now);
        draw();
        requestAnimationFrame(loop);
      };

      const handleCheatInput = (key) => {
        if (game.cheatTimeout) {
          clearTimeout(game.cheatTimeout);
        }

        game.cheatInput += key.toLowerCase();

        if (game.cheatInput.length > 4) {
          game.cheatInput = game.cheatInput.slice(-4);
        }

        if (game.cheatInput === "gfsk") {
          game.cheatEnabled = true;
          showBonusIndicator("üîì ‰ΩúÂºäÊ®°Âºè");
          game.cheatInput = "";
        }

        game.cheatTimeout = setTimeout(() => {
          game.cheatInput = "";
        }, 2000);
      };

      window.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
          event.preventDefault();
          flap();
        }

        if (event.key.length === 1 && /^[a-z]$/i.test(event.key)) {
          handleCheatInput(event.key);
        }

        if (event.key.toLowerCase() === "c" && game.cheatEnabled) {
          game.lives += 1;
          showBonusIndicator("‚ù§Ô∏è ‰ΩúÂºä +1");
          updateHud();
        }
      });

      canvas.addEventListener("pointerdown", () => {
        flap();
      });

      restartBtn.addEventListener("click", () => {
        resetGame();
      });

      toggleModeBtn.addEventListener("click", () => {
        const nextMode = game.mode === "hard" ? "normal" : "hard";
        applyMode(nextMode);
        resetGame();
      });

      applyMode("normal");
      updateHud();
      loop(performance.now());
    </script>
  </body>
</html>
